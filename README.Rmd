---
title: "Untitled"
output: github_document:
    toc: true
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Link to github repository  

## Required Packages  

```{r setup packages results='hide'}
library(tidyverse)
library(httr)
library(jsonlite)
```

## Write functions to contact the NHL Records API  
Note -- to help with ease of tracking variable scope -- function arguments have the letter 'a' for a prefix, variables local to the function have an 'f' for a prefix.  Global variables have a 'g' prefix.
```{r Filter Functions}

#Returns first partial matching entry, unsorted, from input conditions
pullIDDecoder<- function(aName = "", aTeamID= "", aFranchiseID = "") 
{
  #Run a pull against the franchise table to get the full decoding
  fBase<- "https://records.nhl.com/site/api/"
  fEndpoint<- "franchise"
  fCallURL<- paste0(fBase,fEndpoint)
  

  fRawJSON<- GET(fCallURL)
  fJSON_text<- content(fRawJSON, "text")
  fParsedText <- fromJSON(fJSON_text, flatten = TRUE)
  fDF <- as.data.frame(fParsedText)
  
  fTeamList<- as_tibble(fDF)%>%
    filter(toupper(data.teamCommonName) == toupper(aName) | data.id == aFranchiseID | data.mostRecentTeamId == aTeamID)
  
  fDecoder <- list("TeamID" = toString(fTeamList$data.mostRecentTeamId[1]), "FranchiseID" = toString(fTeamList$data.id[1]))
  fDecoder <- lapply(fDecoder, FUN=sub, pattern = "NA", replacement = "")
  
  return(fDecoder)
}

```

```{r Parsed Franchise, warning=FALSE}
#input options for franchise common name, franchise id number, and teamid 
#function returns id, first seasonid, and last seasonid and name of every team in the history of the NHL
getFranchiseInfo<- function(aName = "", aTeamID= "", aFranchiseID = ""){
#Define API url and pull results
fBase<- "https://records.nhl.com/site/api/"
fEndpoint<- "franchise"

#Process our inputs.  If any is non-empty, we need to add a query modifier.
#Choosing to query for FranchiseID, but could easily pull on mostRecentTeamID
fCayenneExp = ""
if(aName!="" | aTeamID != "" | aFranchiseID !="") fCayenneExp <- pullIDDecoder(aName, aTeamID, aFranchiseID)$FranchiseID
#Append the appropriate prefix for this base & endpoint
if(fCayenneExp != "") fCayenneExp <-paste0("?cayenneExp=id=",fCayenneExp)

#Pull API Data
fCallURL<- paste0(fBase,fEndpoint,fCayenneExp)
print(fCallURL)

#Process results into a dataframe and return
fRawJSON<- GET(fCallURL)
fJSON_text<- content(fRawJSON, "text")
fParsedText <- fromJSON(fJSON_text, flatten = TRUE)
fDF <- as.data.frame(fParsedText)

return(fDF)
}
```

```{r Parsed team totals}
#input options for franchise common name and franchise team id number, number runs slightly faster
#function Returns total stats for every franchise (ex roadTies, roadWins, etc)
getFranchiseTotals<- function(aName = "", aTeamID= "", aFranchiseID = ""){
#Define API url and pull results
fBase<- "https://records.nhl.com/site/api/"
fEndpoint<- "franchise-team-totals"

#Process our inputs.  If any is non-empty, we need to add a query modifier.
#Need to pull for FranchiseID
fCayenneExp = ""
if(aName!="" | aTeamID != "" | aFranchiseID !="") fCayenneExp <- pullIDDecoder(aName, aTeamID, aFranchiseID)$FranchiseID
#Append the appropriate prefix for this base & endpoint
if(fCayenneExp != "") fCayenneExp <-paste0("?cayenneExp=franchiseId=",fCayenneExp)

fCallURL<- paste0(fBase,fEndpoint,fCayenneExp)
print(fCallURL)

#Process results into a dataframe and return
fRawJSON<- GET(fCallURL)
fJSON_text<- content(fRawJSON, "text")
fParsedText <- fromJSON(fJSON_text, flatten = TRUE)
fDF <- as.data.frame(fParsedText)

return(fDF)
}
```

```{r Parsed Franchise Season Records}
getFranchiseSeasonRecords<- function(aName = "", aTeamID= "", aFranchiseID = ""){
#Define API url and pull results
fBase<- "https://records.nhl.com/site/api/"
fEndpoint<- "franchise-season-records"

#Process our inputs.  If any is non-empty, we need to add a query modifier.
#Need to pull for FranchiseID
fCayenneExp = ""
if(aName!="" | aTeamID != "" | aFranchiseID !="") fCayenneExp <- pullIDDecoder(aName, aTeamID, aFranchiseID)$FranchiseID
#Append the appropriate prefix for this base & endpoint
if(fCayenneExp != "") fCayenneExp <-paste0("?cayenneExp=franchiseId=",fCayenneExp)

fCallURL<- paste0(fBase,fEndpoint,fCayenneExp)

print(fCallURL)

#Process results into a dataframe and return
fRawJSON<- GET(fCallURL)
fJSON_text<- content(fRawJSON, "text")
fParsedText <- fromJSON(fJSON_text, flatten = TRUE)
fDF <- as.data.frame(fParsedText)

return(fDF)
}
```

```{r Parsed Goalie Records}
#Goalie records for the specified franchise 
#/franchise-goalie-records?cayenneExp=franchiseId=ID
getFranchiseGoalieRecords<- function(aName = "", aTeamID= "", aFranchiseID = ""){
#Define API url and pull results
fBase<- "https://records.nhl.com/site/api/"
fEndpoint<- "franchise-goalie-records"

#Process our inputs.  If any is non-empty, we need to add a query modifier.
#Need to pull for FranchiseID
fCayenneExp = ""
if(aName!="" | aTeamID != "" | aFranchiseID !="") fCayenneExp <- pullIDDecoder(aName, aTeamID, aFranchiseID)$FranchiseID
#Append the appropriate prefix for this base & endpoint
if(fCayenneExp != "") fCayenneExp <-paste0("?cayenneExp=franchiseId=",fCayenneExp)

fCallURL<- paste0(fBase,fEndpoint,fCayenneExp)

print(fCallURL)

#Process results into a dataframe and return
fRawJSON<- GET(fCallURL)
fJSON_text<- content(fRawJSON, "text")
fParsedText <- fromJSON(fJSON_text, flatten = TRUE)
fDF <- as.data.frame(fParsedText)

return(fDF)
}
```


```{r Parsed Skater Records}
#/franchise-skater-records?cayenneExp=franchiseId=ID Skater records, same interaction as goalie endpoint
getFranchiseSkaterRecords<- function(aName = "", aTeamID= "", aFranchiseID = ""){
#Define API url and pull results
fBase<- "https://records.nhl.com/site/api/"
fEndpoint<- "franchise-skater-records"

#Process our inputs.  If any is non-empty, we need to add a query modifier.
#Need to pull for FranchiseID
fCayenneExp = ""
if(aName!="" | aTeamID != "" | aFranchiseID !="") fCayenneExp <- pullIDDecoder(aName, aTeamID, aFranchiseID)$FranchiseID
#Append the appropriate prefix for this base & endpoint
if(fCayenneExp != "") fCayenneExp <-paste0("?cayenneExp=franchiseId=",fCayenneExp)

fCallURL<- paste0(fBase,fEndpoint,fCayenneExp)
print(fCallURL)

#Process results into a dataframe and return
fRawJSON<- GET(fCallURL)
fJSON_text<- content(fRawJSON, "text")
fParsedText <- fromJSON(fJSON_text, flatten = TRUE)
fDF <- as.data.frame(fParsedText)

return(fDF)
}
```

```{r TestRecordsAPI}
gdfFranchiseAll<-getFranchiseInfo()
gdfFranchiseName<-getFranchiseInfo(aName="Devils")
gdfFranchiseNumber<-getFranchiseInfo(aFranchiseID = 2)
gdfFranchiseTeam<-getFranchiseInfo(aTeamID = 2)

gdfFranTotal<-getFranchiseTotals()
gdfFranTotalName<-getFranchiseTotals(aName="Devils")
gdfFranTotalNumber<-getFranchiseTotals(aFranchiseID = 2)
gdfFranTotalTeam<-getFranchiseTotals(aTeamID = 2)

gdfFranSeas<-getFranchiseSeasonRecords()
gdfFranSeasName<-getFranchiseSeasonRecords(aName="Devils")
gdfFranSeasNumber<-getFranchiseSeasonRecords(aFranchiseID = 2)
gdfFranSeasTeam<-getFranchiseSeasonRecords(aTeamID = 2)

gdfFranGoal<-getFranchiseGoalieRecords()
gdfFranGoalName<-getFranchiseGoalieRecords(aName="Devils")
gdfFranGoalNumber<-getFranchiseGoalieRecords(aFranchiseID = 2)
gdfFranGoalTeam<-getFranchiseGoalieRecords(aTeamID = 2)

gdfFranSkat<-getFranchiseSkaterRecords()
gdfFranSkatName<-getFranchiseSkaterRecords(aName="Devils")
gdfFranSkatNumber<-getFranchiseSkaterRecords(aFranchiseID = 2)
gdfFranSkatTeam<-getFranchiseSkaterRecords(aTeamID = 2)

```
```{r Stats Filter}
#Need a different filter function for the different API set.
#This version needs to resolve 
```
```{r Stats API All}
ProcessExpandArgs<- function(aExpand, aTeams)
{
  fExpand<- toupper(aExpand)
  if(fExpand == "") return("")
  if(fExpand == "ROSTER") return("?expand=team.roster")
  if(fExpand == "EZROSTER") return("?expand=person.names")
  if(fExpand == "NEXTSCHED") return("?expand=team.schedule.next")
  if(fExpand == "PREVSCHED") return("?expand=team.schedule.previous")
  if(fExpand == "STATS") return("?expand=team.stats")
  if(fExpand == "TEAMLIST") return(paste0("?teamId=", aTeams))
}


#You should have a function to return parsed data for the following endpoint from the stats API(the user should be able to specify values for any of the eight modifiers listed):âˆ—https://statsapi.web.nhl.com/api/v1/teams

#aExpand can take the following values, pulling different summary expansions:
  #"Roster", "EZRoster", "NextSched","PrevSched","Stats", "TeamList",  ""
  #Note that the TeamList value needs valid teamIDs, and that the common inputs of aName and aNumber supersede this command

#aSeason is a string formatted Y111Y222 restricting the pull to the season of interest.
#By default, an empty string will pull the current season where applicable
#Example:  20142015 to refer to the 2014-2015 hockey season.

#aTeams is a comma separated string of teamIDs and requires the 'TeamList' expansion instruction 
#Example: "4,5,29"
#Note that the common inputs of aName, aTeamID, and aFranchiseID supersede this field
getTeamStats<- function(aExpand="", aSeason = "", aTeams = "", 
                        aName = "", aTeamID= "", aFranchiseID = "")
{
#Process our inputs.  If any is non-empty, we need to add a query modifier.
#Check for a common input
fTeamStr = ""
if(aName!="" | aTeamID != "" | aFranchiseID !="")
  {fTeamStr <- pullIDDecoder(aName, aTeamID, aFranchiseID)$TeamID}
#Append the appropriate prefix for this base & endpoint
if(fTeamStr != "") fTeamStr <-paste0("/",fTeamStr)

  #Process aExpand and aTeams where relevant
  fExpand<- ProcessExpandArgs(aExpand, aTeams)
    
  #process aSeason
  fSeason=if(aSeason != ""){
    #If we already have a modifier, we need to tack this on with an &
    if(fExpand!="") paste0("&season=", aSeason)
    #else we need to use this as a direct modifier
    else paste0("?season=", aSeason)
  }

  #Define API url and pull results
  fBase<- "https://statsapi.web.nhl.com/api/v1/"
  fEndpoint<- "teams"

  fCallURL<- paste0(fBase,fEndpoint,fTeamStr,fExpand,fSeason)
  print(fCallURL)

  #Process results into a dataframe and return
  fRawJSON<- GET(fCallURL)
  fJSON_text<- content(fRawJSON, "text")
  fParsedText <- fromJSON(fJSON_text, flatten = TRUE)
  fDF <- as.data.frame(fParsedText)

return(fDF)
}

#aExpand can take the following values, pulling different summary expansions:
  #"Roster", "EZRoster", "NextSched","PrevSched","Stats", "TeamList",  ""
  #Note that the TeamList value needs valid teamIDs, and that the common inputs of aName and aNumber supersede this command

#aSeason is a string formatted Y111Y222 restricting the pull to the season of interest.
#By default, an empty string will pull the current season where applicable
#Example:  20142015 to refer to the 2014-2015 hockey season.

#aTeams is a comma separated string of teamIDs and requires the 'TeamList' expansion instruction 
#Example: aTeams = "4,5,29"
#Note that the common inputs of aName, aTeamID, and aFranchiseID supersede this field

#"Roster", "EZRoster", "NextSched","PrevSched","Stats", "TeamList",  ""
gdfTeamStatsa<- getTeamStats(aExpand = "Roster")
gdfTeamStatsb<- getTeamStats(aExpand = "EZRoster")
gdfTeamStatsc<- getTeamStats(aExpand = "NextSched")
gdfTeamStatsd<- getTeamStats(aExpand = "PrevSChed")
gdfTeamStatse<- getTeamStats(aExpand = "Stats")
gdfTeamStatsf<- getTeamStats(aExpand = "Teamlist", aTeams = "4,5,7")
gdfTeamStatsg<- getTeamStats(aSeason = "20142015")
gdfTeamStatsh<- getTeamStats(aExpand = "Stats", aSeason = "20142015")
gdfTeamStatsi<- getTeamStats(aName = "Devils")
gdfTeamStatsj<- getTeamStats(aFranchiseID = 2)
gdfTeamStatsk<- getTeamStats(aTeamID = 2)
gdfTeamStatsl<- getTeamStats(aTeamID = "2", aTeams = "4,5,7")

gdfTeamStatsm<-getTeamStats(aName="Devils")
gdfTeamStatsn<-getTeamStats(aFranchiseID = 2)
gdfTeamStatso<-getTeamStats(aTeamID = 2)


```

```{r One-Stop-Wrapper Function}
```

##Example Analysis


## GitHub Documents

This is an R Markdown format used for publishing markdown documents to GitHub. When you click the **Knit** button all R code chunks are run and a markdown file (.md) suitable for publishing to GitHub is generated.

## Including Code

You can include R code in the document as follows:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
